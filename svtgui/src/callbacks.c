/*
 * Handle all the GUI callbacks. This is the core of the svtgui application,
 * Function implemented here handle,
 *
 * - all the button click events
 * - events generated by the menu items
 * - initialization/finalization/execution of embedded Python
 * 
 * AB/SS
 */
#include <stdio.h>
#include <gnome.h>
#include <gtk/gtk.h>
#include <assert.h>
#include <ctype.h>

#include "Python.h"

#include "config.h"
#include "callbacks.h"
#include "interface.h"
#include "support.h"
#include "graph_global.h"
#include "svtvme_public.h"
#include "utils.h"

#define toString(a) (#a)

/* 'board' is a static pointer to the SVT board data structure */
static svtvme_h board = 0;
static gchar *message = "Hexadecimal only for now (work in progress) ...\n";
static gint current_board_type = -1;

/* The global GUI components which make GUI access easy */
extern GlobalComponent svt_gc;

/* Saving data to file */
typedef struct {
  gchar defaultFilename[MAX_STRING_LEN];
  gchar currentFilename[MAX_STRING_LEN];
} pgmContext;

static pgmContext fc;

/* 
 * Help topics, opens the existing svtgui documentation in a browser.
 * We have to see whether the in-built Gnome help browser could be used
 * instead of netscape. Probably, if you are in a Gnome session.
 *
 * item   - Pointer to the 'Help Topic' MenuItem widget
 * data   - Pointer to generic user data which one may pass to this routine when
 *          the menu item is selected
 */
void svtgui_showDocCB(GtkMenuItem *item, gpointer data) {
  gchar docfile[MAX_STRING_LEN];
  g_snprintf(docfile, NEL(docfile), "%s/%s", 
       getenv("SVTVME_DIR"), "svtgui/svtgui-doc.html");
  if (docfile != NULL) {
    gchar *url = g_strconcat("file:", docfile, NULL);
    gnome_help_goto(NULL, url);

    g_free(url);
  }
  else {
    gnome_error_dialog(_("Could not find the documenation file!"));
  }
}

/* 
 * Use the C board handle and parasitically open a board from Python 
 */
void svtgui_initPython() {
  gchar tag[100];
  gchar crate_name[32];
  if (board && Py_IsInitialized()) {
    gint bType    = svtvme_boardType(board);
    gint slot_num = svtvme_boardSlot(board);    
    gint ercode   = svtvme_boardCrate(board, crate_name);
    PyRun_SimpleString("from SvtVme import *\n");
    g_snprintf(tag, NEL(tag), "b = Board(\"%s\", %d, %d, \"_%lx_svtvme_h\")", 
                              crate_name, slot_num, bType, (long)board);
    PyRun_SimpleString(tag);
  }
}

/* 
 * Initialize the Python interpreter. I We do not look for an open board-handle and pass 
 * that to Python immediately after the initializtion of the interpreter.
 */
void svtgui_startPython(void) {
  gchar *crate_name, *board_name;
  gint slot_num;

  /* Initialize the Python interpreter.  Required. */
  g_message("Initializing Python interpreter ..... ");
  Py_Initialize();
  if (!board) {
    g_message("Opening board handle first ...");
    crate_name = gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(svt_gc.combo_crate)->entry)); 
    board_name = gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(svt_gc.combo_board)->entry)); 
    slot_num   = atoi(gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(svt_gc.combo_slot)->entry))); 

    if (board_name == NULL || crate_name == NULL || slot_num <= 0) {
      g_warning("svtgui_startPython() -> Possibly wrong configuration of %s/%s/%d", 
                  crate_name, board_name, slot_num); 
      /* a Py_Finalize() is not necessary here, since the application stays and one can 
         correct the mistyping */
      return;
    }
    svtgui_ensureOpenBoard(crate_name, board_name, slot_num);
  } 
  svtgui_initPython();
}

/* Release resources and shutdown the Python interpreter */
void svtgui_shutPython(void) {
  if (Py_IsInitialized()) {
    g_message("Shutting down the Python interpreter ..... ");
    Py_Finalize();
  }
}

/* 
 * Read Python commands from the script area and execute. It is 
 * assumed that a valid C handle to a board exists, i.e a board
 * is open and that Python knows about it.
 * The board handle in Python MUST be 'b', i.e b.isTmode() etc.
 *
 * button  - Pointer to the 'Exec' button in the 'Scripting' tab
 * data    - Pointer to generic user data which one may pass to this routine when
 *           the button is clicked
 */
void svtgui_execScriptCB(GtkButton *button, gpointer data) {
  GtkWidget *script_area;
  gchar *text;

  assertInterpreter();
  script_area = (GtkWidget *) data;
  text = gtk_editable_get_chars(GTK_EDITABLE(script_area), 0, -1);
  PyRun_SimpleString(text);
}

/* Make sure that the Python interpreter is initialized */
void assertInterpreter(void) {
  if (!Py_IsInitialized()) {
    svtgui_startPython();
  }
}

/* 
 * Execute Python commands from a file with 'this' board.
 *
 * If Python interpreter is initialized and the board handle
 * is open, it is passed to Python. It must be noted that Python 
 * should not try to reopen the board already open. 
 * It should simply assume that a board object, b, is available in Global scope!
 *
 * data   - Pointer to generic user data which one may pass to this routine when
 *          the menu item is selected
 */
void svtgui_runScript(gpointer data) {
  FILE *fp;
  gchar *fname;
  gint status;

  assertInterpreter();
  fname = gtk_entry_get_text(GTK_ENTRY(gnome_file_entry_gtk_entry((GnomeFileEntry *) data)));
  g_return_if_fail(fname != NULL);

  fp = fopen(fname, "r");
  if (!fp) {
    g_warning("Could not open file, %s", fname);
    return;
  }
  status = PyRun_SimpleFile(fp, fname);
  fclose(fp);
}

/* 
 * Send freeze command via the spy control board. This function only needs to know
 * the name of the crate; it assumes the SC slot number to be 3 which is
 * (mostly) the case.
 * 
 * button  - Pointer to the 'Freeze/Release' button in the 'Spy Buffer' tab
 * data    - Pointer to generic user data which one may pass to this routine when
 *           the button is clicked. We pass here the address of the entry
 *           box which displays the error code.
 */
void svtgui_sendFreezeCB(GtkButton *button, gpointer data) {
  uint4 state;
  gint error, status, type, serial;
  gchar str[10];

  gchar *name       = gtk_widget_get_name(GTK_WIDGET(button));
  gchar *crate_name = gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(svt_gc.combo_crate)->entry)); 
  GtkWidget *widget = (GtkWidget *) data;

  svtvme_h scB = svtvme_openBoard(crate_name, 3, SVTB);
  if (!scB) {
    g_warning("SC Board handle null %p", scB);
    return;
  }
  status = svtvme_getBoardIdentifier(scB, &type, &serial);
  if (status) {
    g_warning("Could not access board identifier for SC in %s", crate_name);
    return;
  }

  /* Now close the generic board and check the board type */
  svtvme_closeBoard(scB);

  if (type != SC) {
    g_warning("Board type = %d does not match for SC = %d in %s", 
                   type, SC, crate_name);
    return;
  }

  /* Now open Spy control board */
  scB = svtvme_openBoard(crate_name, 3, type);
  if (!scB) {
    g_warning("Could not open Spy Control Board, handle = %p", scB);
    return;
  }

  /* Either set freeze or release */
  if (strcmp(name, "sc_freeze_button") == 0) {
    error = svtvme_setState(scB, SC_FREEZE_FORCE, 1);
  }
  else if (strcmp(name, "sc_release_button") == 0) {
    error = svtvme_setState(scB, SC_FREEZE_FORCE, 0);
  }

  /* Now display error code in the output entry box */
  if (!error) {
    error = svtvme_getState(scB, SC_BACKPLANE_FREEZE, &state);
    g_snprintf(str, NEL(str), "%u", state);
    gtk_entry_set_text(GTK_ENTRY(widget), str);
  }
  else {
    g_snprintf(str, NEL(str), "%d", error);
    gtk_entry_set_text(GTK_ENTRY(widget), str);
  }
  svtvme_closeBoard(scB);
    
  /* Update the Spy status immediately */
  svtgui_readSpyStatus();
}

/* Initialize global environment */
void svtgui_initApplication() {
  svt_gc.verbose_mode = FALSE;
  svt_gc.owpl_mode    = TRUE;
}

/* 
 * Clear the Board registers. This simply clears the I/O boxes.
 * button  - Pointer to the 'Clear Reg' button in the 'Register' tab
 * data    - Pointer to generic user data which one may pass to this routine when
 *           the button is clicked
 */
void svtgui_clearRegCB(GtkButton *button, gpointer data) {
  gchar *name = gtk_widget_get_name(GTK_WIDGET(button));
  if (strcmp(name, "button_clear_reg_all") == 0) {
    gint i;
    GlobalComponent *svtgc = (GlobalComponent *) data;
    for (i = 0; i < NUM_REGS; i++)  
      svtgui_clearBoardRegister(svtgc->entry_reg[i]);
  }
}

/* Clear the entry boxes for the board registers */
void svtgui_clearBoardRegister(GtkWidget *widget) {
   gtk_entry_set_text(GTK_ENTRY(widget), "");
}

/* Read board status and update GUI elements */
void svtgui_readStatus(gint board_type) {
  /* Not valid for SC */
  if (board_type != SC) svtgui_readTmode();

  /* Not valid for SC and AMB */
  if (board_type != AMB && board_type != SC) svtgui_readHold();

  /* FIFOs for HF seem not working */
  if (board_type != HF)  svtgui_readFifoStatus();

  svtgui_readSpyStatus();
  svtgui_readErrorReg(board_type);
  svtgui_resetClock(svt_gc.clock);
}

/* 
 * Event generated by button clicks. All the button generated events are handled
 * in a single function.
 * button  - Pointer to the Button widget
 * data    - Pointer to generic user data which one may pass to this routine when
 *           the button is pushed
 */
void svtgui_buttonClickCB(GtkButton *button, gpointer data) {	
  gint i; 
  gchar *label = 0;

  gchar *name = gtk_widget_get_name(GTK_WIDGET(button));

  gchar *crate_name  = gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(svt_gc.combo_crate)->entry)); 
  gchar *board_name  = gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(svt_gc.combo_board)->entry)); 
  gint slot_num = atoi(gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(svt_gc.combo_slot)->entry))); 

#ifdef __DEBUG__
  g_print("DEBUG: Crate/Board/Slot: %s/%s/%d\n", crate_name, board_name, slot_num);
  g_print("DEBUG: button_click_cb() -> This button is: %s\n", name);
#endif

  if (board_name == NULL || crate_name == NULL || slot_num <= 0) {
    g_message("button_click_cb() -> Possibly wrong configuration of %s/%s/%d", 
                crate_name, board_name, slot_num); 
    return;
  }

  /* 
   * Ensure that the correct board is open. This means if a board handle is NULL
   * or the board handle is valid but a new configuration has been selected, then
   * it automatically closes the previous board and open a new one reading relevant
   * info from the 3 combo boxes. 
   */
  svtgui_ensureOpenBoard(crate_name, board_name, slot_num);

  /*
   * Get info about button label used for Enable/Disable 
   */
  if (strcmp(name, "button_refresh") != 0) label = gui_getButtonLabel(button);

  /* 
   *  Refresh the general status panel 
   */
  if (strcmp(name, "button_refresh") == 0) {
    svtgui_readStatus(svtvme_boardType(board));
  }
  /* 
   * Init board 
   */
  else if (strcmp(name, "button_init") == 0) {
    svtgui_initBoard();
  }
  /* 
   * Enable/Disble Test Mode 
   */
  else if (strcmp(name, "button_test_mode") == 0) {
    gint error;

    if (strcmp(label, "Enable") == 0) 
      error = svtgui_setTmode(TRUE);
    else
      error = svtgui_setTmode(FALSE);
  }
  /* 
   * Read/write at address
   */
  else if (strcmp(name, "button_add_go") == 0) {
    svtgui_awordOperation();
  }
  /*
   * Test Memory
   */
  else if (strcmp(name, "button_mem_test") == 0) {
    svtgui_testMemory();
  }
  /* 
   * Perform memory operation
   */
  else if (strcmp(name, "button_mem_go") == 0) {
    svtgui_memoryOperation();
  }
  /* 
   * Read Spy Buffer Status 
   */
  else if (strcmp(name, "button_spy_status_read") == 0) {
    svtgui_readSpyStatus();
  }
  /* 
   * Reset Spy Buffer Status 
   */
  else if (strcmp(name, "button_spy_reset") == 0) {
    svtgui_resetSpy();
  }
  /*  
   * Read Spy Buffers 
   */
  else if (strcmp(name, "button_spy_read") == 0) {
    svtgui_readSpyBuffer();
  }
  /*  
   * Read/Write registers
   */
  else if (
    (strcmp(name, "button_read_reg[0]") == 0) || 
    (strcmp(name, "button_read_reg[1]") == 0) || 
    (strcmp(name, "button_read_reg[2]") == 0) || 
    (strcmp(name, "button_read_reg[3]") == 0) || 
    (strcmp(name, "button_read_reg[4]") == 0) ) 
  {
    svtgui_readBoardRegister(GPOINTER_TO_INT(data));
  }
  else if (
    (strcmp(name, "button_write_reg[0]") == 0) || 
    (strcmp(name, "button_write_reg[1]") == 0) || 
    (strcmp(name, "button_write_reg[2]") == 0) || 
    (strcmp(name, "button_write_reg[3]") == 0) || 
    (strcmp(name, "button_write_reg[4]") == 0) )
  {
    svtgui_writeBoardRegister(GPOINTER_TO_INT(data));
  }
  else if ((strcmp(name, "button_read_reg_all") == 0) ||
           (strcmp(name, "button_write_reg_all") == 0) ||
           (strcmp(name, "button_test_reg_all") == 0)) 
  {
    gchar *option = (gchar *) data;
    for (i = 0; i < NUM_REGS; i++) {
      if (strcmp(option, "Read") == 0) 
        svtgui_readBoardRegister(i);
      else if (strcmp(option, "Write") == 0) 
        svtgui_writeBoardRegister(i);
      else if (strcmp(option, "Test") == 0) 
        svtgui_testBoardRegister(i);
    }
  } 
  /*  FIFO Status  */
  else if (strcmp(name, "button_fifo_status") == 0) {
    svtgui_readFifoStatus();
  }
  /*  FIFO Read  */
  else if (strcmp(name, "button_fifo_read") == 0) {
    svtgui_readFifo();
  }
  /* Send Data */
  else if (strcmp(name, "button_send_data") == 0) {
    svtgui_sendData();
  }
  /* Python */
  else if (strcmp(name, "python_exec_button") == 0) {
    svtgui_runScript(data);
  }
  else if (strcmp(name, "python_save_button") == 0) {
    svtgui_saveScript(data);
  }
}

/* Reset Spy pointer to 0 and update GUI */
void svtgui_resetSpy(void) {
  gint spy_id = 0, error, counter = 0;
  gchar *spy_buf;
  gchar str[6];

  if (!board) return;

  /* Get which spy buffer is selected */
  spy_buf = gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(svt_gc.combo_spy)->entry));
  spy_id = svtvme_stringToObject(spy_buf);

  if (spy_id) error = svtvme_resetSpy(board, spy_id);
    
  counter = svtvme_spyCounter(board, spy_id);  
  g_snprintf(str, NEL(str), "%d", counter);

  gtk_entry_set_text(GTK_ENTRY(svt_gc.entry_pointer), str);
  gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_spy_wrap, svt_gc.pix_file_green); 
}
 
/* Execute Board Memory related operations */
void svtgui_memoryOperation(void) {
  gint ndata, error;
  uint4 offset, *data;

  gchar *mem_name = gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(svt_gc.combo_mem)->entry));
  gint mem_id = svtvme_stringToObject(mem_name);

  if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_mem_all)))
    ndata  = svtvme_nWords(mem_id);
  else  
    ndata = atoi(gtk_entry_get_text(GTK_ENTRY(svt_gc.entry_mem_nw)));

  offset = atoi(gtk_entry_get_text(GTK_ENTRY(svt_gc.entry_offset)));

  /* Allocate memory */
  data = g_new0(uint4, ndata);
  if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_mem_write))) {
    /* Data source */
    if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_mem_dump))) {
      gchar *datafile = gtk_entry_get_text(GTK_ENTRY(
         gnome_file_entry_gtk_entry((GnomeFileEntry *) svt_gc.entry_file)));
      error = tool_loadFromFile(datafile, ndata, data);
    }
    else {
      if (svt_gc.owpl_mode)   /* one-word-per-line */
        error = svtgui_loadFromUI(GTK_TEXT(svt_gc.input_area), ndata, data);
      else
        error = svtgui_nloadFromUI(GTK_TEXT(svt_gc.input_area), ndata, data);
    }
    if (error < 0) {
      g_warning("Cannot load data, no action taken!");
      if (data) g_free(data);  /* Deallocate */
      return;
    }
    error = svtvme_writeMemoryFragment(board, mem_id, offset, ndata, data);
    if (error != 0) {
      g_warning("Writing data fragment to memory, code = %d", error);
      if (data) g_free(data); /* Deallocate */
      return;
    }
  }
  else {
    error = svtvme_readMemoryFragment(board, mem_id, offset, ndata, data);
    if (error != 0) {
      g_warning("Reading data fragment from memory, code = %d", error);
      if (data) g_free(data);  /* Deallocate */
      return;
    }
    if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_mem_display))) {
      svtgui_showData(GTK_TEXT(svt_gc.output_area), mem_name, ndata, data);
    }
    else {
      gchar *filename = gtk_entry_get_text(GTK_ENTRY(
         gnome_file_entry_gtk_entry((GnomeFileEntry *) svt_gc.entry_file)));
      tool_saveData(filename, svt_gc.owpl_mode, ndata, data); 
    }
  }    
  /* Deallocate */
  if (data) g_free(data);
}

/* 
 * Display Spy buffer data or memory/Fifo content 
 * widget  - The GtkText widget which display data
 * name    - Element name
 * ndata   - Number of words to be displayed
 * data    - Data array
 */
void svtgui_showData(GtkText *widget, const gchar *name, gint ndata, uint4 *data) {
  gint i;
  gchar str[8], item_name[32];

  g_snprintf(item_name, NEL(item_name), "%s Data:\n", name);
  gtk_text_insert(widget, NULL, NULL, NULL, item_name, -1);
  for (i = 0; i < ndata; i++) {
    g_snprintf(str, NEL(str), "%6.6x ", data[i]);
    gtk_text_insert(widget, NULL, NULL, NULL, str, -1);
    if ((i+1)%10 == 0)
       gtk_text_insert(widget, NULL, NULL, NULL, "\n", -1);
  }
  gtk_text_insert(widget, NULL, NULL, NULL, "\n\n", -1);
}

/* Test board memory */
void svtgui_testMemory() {
  gchar str[120];
  gint ntimes, n_error, error;

  gchar *ptr  = gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(svt_gc.combo_mem)->entry));
  gint mem_id = svtvme_stringToObject(ptr);

  if (!board) return;

  /* Get the number of times memory must be accessed */
  ptr = gtk_entry_get_text(GTK_ENTRY(svt_gc.entry_mem_times));
  if (!strlen(ptr))
    ntimes = 1;
  else
    ntimes = atoi(ptr);

  error = svtvme_testMemory(board, mem_id, ntimes, STOP_AT_ITERATION_END, &n_error);
  if (error == 0) {
    g_snprintf(str, NEL(str), "# of errors encountered in memory test = %d\n", n_error);
    gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, str, -1);

    g_snprintf(str, NEL(str), "%d errors\n", n_error);
    gtk_label_set_text(GTK_LABEL(svt_gc.label_memtest), str);
  }
  else {
    g_snprintf(str, NEL(str), "Error occurred in memory test, code = %d\n", error);
    gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, str, -1);
  }
}

/* A single word operation */
void svtgui_awordOperation() {
  uint4 addr, word;
  gint i, error = 0, ntimes;
  gchar str[10];

  gchar *ptr = gtk_entry_get_text(GTK_ENTRY(svt_gc.entry_address)); 
  g_return_if_fail(strlen(ptr));
  sscanf(ptr, "%x", &addr);

  if (!board) return;

  /* Get the number of times a single word should be read/written */
  ptr = gtk_entry_get_text(GTK_ENTRY(svt_gc.entry_times)); 
  if (!strlen(ptr))
    ntimes = 1;
  else
    ntimes = atoi(ptr);
  
  if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_read_add))) {
    gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, 
        "Result of readWord():\n", -1);
    for (i = 0; i < ntimes; i++) {
      error &= svtvme_readWord(board, addr, &word);
      g_snprintf(str, NEL(str), "%6.6x\n", word);
      gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, str, -1);
    }
  }
  else {
    ptr = gtk_entry_get_text(GTK_ENTRY(svt_gc.entry_result)); 
    if (!strlen(ptr)) {
      g_message("No data to write to memory, no action taken!");
      return;
    }
    sscanf(ptr, "%x", &word);
    for (i = 0; i < ntimes; i++) {
      error &= svtvme_writeWord(board, addr, word);
    }
  }
}

/* Send data to board */
void svtgui_sendData() {
  uint4 *data = 0;
  gint ndata, nwread;

  if (!board) return;

  if ( gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_send_option[0])) ||
       gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_send_option[1])) ) {

    ndata = atoi(gtk_entry_get_text(GTK_ENTRY(svt_gc.send_nevt_entry)));
    data = g_new0(uint4, ndata);

    /* Data source */
    if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_data_source[1]))) {
      gchar *datafile = gtk_entry_get_text(GTK_ENTRY(
         gnome_file_entry_gtk_entry((GnomeFileEntry *) svt_gc.send_entry_file)));
      nwread = tool_loadFromFile(datafile, ndata, data);
    }
    else {
      if (svt_gc.owpl_mode)  /* one-word-per-line */
        nwread = svtgui_loadFromUI(GTK_TEXT(svt_gc.input_area), ndata, data);
      else
        nwread = svtgui_nloadFromUI(GTK_TEXT(svt_gc.input_area), ndata, data);
    }
    if (nwread < 0) {
      if (data) g_free(data);
      return;
    }
  }

  /* Call one out of the 5 send functions */
  if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_send_option[0]))) {
    int spd = FASTER;
    gchar *speed = gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(svt_gc.send_combo_speed)->entry));
    if (!strcmp(speed, "SLOWER")) spd = SLOWER;
    svtvme_sendDataOnce(board, ndata, data, spd);
  }
  else if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_send_option[1]))) {
    svtvme_sendDataLoop(board, ndata, data);
  }
  else if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_send_option[2]))) {
    svtvme_resendDataOnce(board);
  }
  else if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_send_option[3]))) {
    svtvme_resendDataLoop(board);
  }
  else {
    svtvme_resendData(board);
  }
  if ( gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_send_option[0])) ||
       gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_send_option[1])) ) {
    if (data) g_free(data);
  }
}

/* Read status of all the FIFOs present in a board */
void svtgui_readFifoStatus() {
  gint i, result = 1, error, n_elem = 0, status;
  gint fifoIds[MAX_FIFO_ELEM];
  gint gEmpty=0, gFull=0, gHold=0, gData=0;
  gchar fifo_name[32];
  gchar** words;
  gchar* board_name;
  gchar tag[2];

  if (!board) return;
  board_name = gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(svt_gc.combo_board)->entry)); 

  status = svtvme_getFifoList(svtvme_boardType(board), MAX_FIFO_ELEM, &n_elem, fifoIds);
  if (n_elem <= 0) return;

  for (i = 0; i < n_elem; i++) {
    svtvme_objectName(fifoIds[i], fifo_name);
#if 0
    if (fifoIds[i] == TF_BP_FIFO) continue; 
#endif
#ifdef __DEBUG__
    g_print("DEBUG. Fifo[%d] = %d\n", i, fifoIds[i]);
#endif
    error = svtvme_isEmpty(board, fifoIds[i]);
    if (error < 0) {
      g_warning("While reading status for FIFO %s/%d, error = %d", 
            fifo_name, fifoIds[i], error);
      gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_fifo[i], svt_gc.pix_file_gray);
      break;
    }
    result &= error;
    if (svtvme_isFull(board, fifoIds[i])) { /* fifo is full=overflow */
      gFull=1;
      gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_fifo[i], svt_gc.pix_file_red); 
    }
    else if (svtvme_isHold(board, fifoIds[i])) { /* fifo is asserting hold */
      gHold=1;
      gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_fifo[i], svt_gc.pix_file_yellow); 
    }
    else if (svtvme_isEmpty(board, fifoIds[i])) { /* fifo is empy */
      gEmpty+=1;
      gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_fifo[i], svt_gc.pix_file_white); 
    }
    else { /* fifo had data ready to be read */
      gData=1;
      gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_fifo[i], svt_gc.pix_file_green); 
    }

    /* Label the FIFOs with shortened names */
    words = g_strsplit(fifo_name,"_", 4);
    if (svtvme_boardType(board) == HF) 
      tag[0] = words[2][0];
    else                             
      tag[0] = words[1][0];
    tag[1] = '\0';
    gtk_label_set_text(GTK_LABEL(svt_gc.name_fifo[i]), tag); 
  }
  if (gFull) {
    gtk_label_set_text(GTK_LABEL(svt_gc.label_fifo), "Full");
    gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_fifo_status, svt_gc.pix_file_red); 
  }
  else if (gHold) {
    gtk_label_set_text(GTK_LABEL(svt_gc.label_fifo), "Hold");
    gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_fifo_status, svt_gc.pix_file_yellow); 
  }
  else if (gData) {
    gtk_label_set_text(GTK_LABEL(svt_gc.label_fifo), "With data");
    gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_fifo_status, svt_gc.pix_file_green); 
  }
  else if (gEmpty==n_elem) { /* all fifo must be empty to say global status = empty */
    gtk_label_set_text(GTK_LABEL(svt_gc.label_fifo), "Empty");
    gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_fifo_status, svt_gc.pix_file_white); 
  }
  else {
    gtk_label_set_text(GTK_LABEL(svt_gc.label_fifo), "Unknown");
    gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_fifo_status, svt_gc.pix_file_gray); 
  } 
}

/* 
 * Read contents of Fifos in a board 
 */
void svtgui_readFifo() {
  gint num_words, error = 0, more_data;
  gchar crate_name[32], board_name[16];
  gint slot_num, ercode;
  uint4 *data;
  
  /* Get which FIFO is selected */
  gchar *fifo_name = gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(svt_gc.combo_fifo)->entry));
  gint fifo_id = svtvme_stringToObject(fifo_name);
  g_return_if_fail(fifo_id);

#if 0
  if (fifo_id == TF_BP_FIFO) {
    g_warning("TF_BP_FIFO reading has a problem");
    return;
  }
#endif
#ifdef __DEBUG__
  g_print("DEBUG. Selected FIFO, %s %d\n", fifo_name, fifo_id);
#endif  

  if (!board) return;
  ercode   = svtvme_boardCrate(board, crate_name);
  ercode   = svtvme_boardName(svtvme_boardType(board), board_name);
  slot_num = svtvme_boardSlot(board);    

  if (svtvme_isEmpty(board, fifo_id)) {
    g_message("Nothing to read, %s is empty", fifo_name);
    return;
  }
  
  /* Get the num of words to be read */
  if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_read_all_fifo)))
    num_words = MAX_FIFO_LENGTH; 
  else
    num_words = atoi(gtk_entry_get_text(GTK_ENTRY(svt_gc.entry_fifo_nw)));
  
  /* Allocate memory */
  data = g_new0(uint4, num_words);
  if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_read_all_fifo)))
    error = svtvme_readAllFifo(board, fifo_id, num_words, data, &more_data);
  else 
    error = svtvme_readFifo(board, fifo_id, num_words, data);
  
  if (!error) {
    if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_display_fifo))) {
      svtgui_showData(GTK_TEXT(svt_gc.output_area), fifo_name, num_words, data);
    }
    else if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_dump_fifo))) {
      gchar *filename = gtk_entry_get_text(GTK_ENTRY(
         gnome_file_entry_gtk_entry((GnomeFileEntry *) svt_gc.entry_fifo_file)));
      tool_saveData(filename, svt_gc.owpl_mode, num_words, data);
    }
  }
  else {
    g_warning("While reading FIFO, code = %d", error);
  }
  /* Release resources */
  g_free (data);
}

/* 
 * Read Spy buffer data 
 */
void svtgui_readSpyBuffer() {
  gint num_words, words_read = 0;
  uint4 *data, *eedata, pointer;
  gint spy_id = 0, status, n_elem = 0, spyIds[MAX_SPY_ELEM];
  gchar *spy_buf, crate_name[32], board_name[16];
  gint i, eeonly = 0, nee = 0, j = 0, ercode, slot_num;

  if (!board) return;

  ercode   = svtvme_boardCrate(board, crate_name);
  ercode   = svtvme_boardName(svtvme_boardType(board), board_name);
  slot_num = svtvme_boardSlot(board);    

  status = svtvme_getSpyList(svtvme_boardType(board), MAX_SPY_ELEM, &n_elem, spyIds);
  if (n_elem <= 0) return;

  /* Get which spy buffer is selected */
  spy_buf = gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(svt_gc.combo_spy)->entry));
  spy_id  = svtvme_stringToObject(spy_buf);

  g_return_if_fail(spy_id > 0);

  if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.ee_check_button))) eeonly = 1;

  if (!svtvme_isFrozen(board, spy_id)) {
    g_warning("Spy buffer %s of %s/%s/%d not frozen!", 
                       spy_buf, crate_name, board_name, slot_num);
    return;
  }
  pointer = svtvme_spyCounter(board, spy_id);

  /* Get the num of words to be read */
  if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_spy_all)))
    num_words = SPY_LENGTH_ANY; 
  else
    num_words = atoi(gtk_entry_get_text(GTK_ENTRY(svt_gc.text_spy_num_word)));

  /* Allocate memory */
  data = g_new0(uint4, num_words);
  if (svtvme_isWrapped(board, spy_id))
    words_read = svtvme_readSpyTail(board, spy_id, num_words, data);
  else 
    words_read = svtvme_readSpyTail(board, spy_id, MIN(num_words, pointer), data);

  if (words_read < 0) {
    g_warning("button_click_cb() -> Spy buffer %d not read correctly %s/%s/%d", 
                      spy_id, crate_name, board_name, slot_num);
    g_print("Error Code = %d\n", words_read);
    /* Deallocate before returning */
    g_free (data);
    return;
  }

  if (eeonly) {
    for (i = 0; i < words_read; i++) {
      if (data[i] >> 22 & 0x1) nee++;
    }
    eedata = g_new0(uint4, nee);  /* Allocate extra memory for EE words */
    for (i = 0; i < words_read; i++) {
      if (data[i] >> 22 & 0x1) eedata[j++] = data[i];
    }
  }

  if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_spy_display))) {
    svtgui_showData(GTK_TEXT(svt_gc.output_area), spy_buf, (eeonly) ? nee : words_read, 
                                                           (eeonly) ? eedata : data);
  }
  else if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(svt_gc.radio_spy_dump))) {
    gchar *filename = gtk_entry_get_text(GTK_ENTRY(
         gnome_file_entry_gtk_entry((GnomeFileEntry *) svt_gc.text_spy_file)));
    tool_saveData(filename, svt_gc.owpl_mode, (eeonly) ? nee : words_read, (eeonly) ? eedata : data);
  }
  /* Release resources */
  if (eeonly) g_free (eedata);
  g_free (data);
}

/* 
 * Put a board to test/run mode, a potentially dangerous action
 * mode  - A boolean to decide on Test/Run mode
 */
gint svtgui_setTmode(gboolean mode) {
  gint error;
  if (mode) {
    error = svtvme_setTmode(board);
    if (svtvme_isTmode(board)) {
      gtk_label_set_text(GTK_LABEL(svt_gc.label_tmode), "Test Mode");
      gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_tmode, svt_gc.pix_file_red); 
      gui_setButtonLabel(GTK_BUTTON(svt_gc.button_test_mode), "Disable");
    }
    else {
      g_warning("svtgui_setTmode() -> Problem setting Test Mode, Error Code = %d", error);
    }
  }
  else {
    error = svtvme_init(board);
    if (!svtvme_isTmode(board)) {
      gtk_label_set_text(GTK_LABEL(svt_gc.label_tmode), "Run Mode");
      gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_tmode, svt_gc.pix_file_green); 
      gui_setButtonLabel(GTK_BUTTON(svt_gc.button_test_mode), "Enable");
    }
    else {
      g_warning("svtgui_setTmode() -> Problem setting Run Mode, Error Code = %d", error);
    }
  }
  return error;
}


/* Read whether a board is in test/run mode */
void svtgui_readTmode(void) {
  gint result = svtvme_isTmode(board);
  if (result) {
    gtk_label_set_text(GTK_LABEL(svt_gc.label_tmode), "Test Mode");
    gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_tmode, svt_gc.pix_file_red); 
    gui_setButtonLabel(GTK_BUTTON(svt_gc.button_test_mode), "Disable");
  }
  else {
    gtk_label_set_text(GTK_LABEL(svt_gc.label_tmode), "Run Mode");
    gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_tmode, svt_gc.pix_file_green); 
    gui_setButtonLabel(GTK_BUTTON(svt_gc.button_test_mode), "Enable");
  }
}

/* Read output hold status of a board */
void svtgui_readHold(void) {
  gint result = svtvme_isHeld(board); 
  if (result) {
    gtk_label_set_text(GTK_LABEL(svt_gc.label_hold), "Held");
    gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_hold, svt_gc.pix_file_red); 
  }
  else {
    gtk_label_set_text(GTK_LABEL(svt_gc.label_hold), "Free");
    gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_hold, svt_gc.pix_file_green); 
  }
}

/* Send an init to a board */
void svtgui_initBoard(void) {
  gint error = svtvme_init(board);
  if (error == 0) {
    gtk_label_set_text(GTK_LABEL(svt_gc.label_init), "Succeeds");
    gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_init, svt_gc.pix_file_green); 
    svtgui_setTmode(FALSE);
  }
  else {
    gtk_label_set_text(GTK_LABEL(svt_gc.label_init), "Fails");
    gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_init, svt_gc.pix_file_red); 
  }
}

/* 
 * Read board register values 
 * index  - Index in the array of five registers
 */
void svtgui_readBoardRegister(gint index) {
  gint error;
  uint4 state = 0;
  gchar result_str[20], mess[100];

  gchar *str = gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(svt_gc.combo_reg[index])->entry)); 
  if (svt_gc.verbose_mode) {
    g_snprintf(mess, NEL(mess), "INFO. Reading Reg %s = ", str);
    gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, mess, -1);
  }
  error = svtvme_getState(board, svtvme_stringToObject(str), &state);     
  if (!error) {
    g_snprintf(result_str, NEL(result_str), "%x", state);
    if (svt_gc.verbose_mode) {
      gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, result_str, -1);
      gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, "\n", -1);
    }
    gtk_entry_set_text(GTK_ENTRY(svt_gc.entry_reg[index]), result_str);
  }
  else {
    g_snprintf(result_str, NEL(result_str), "Error = %d\n", error);
    gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, result_str, -1);
  } 
}

/* 
 * Set values of the board registers 
 * index - Index in the array of five registers
 */
void svtgui_writeBoardRegister(gint index) {
  gint error;
  uint4 val = 0;
  gchar result_str[20];

  gchar *str   = gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(svt_gc.combo_reg[index])->entry)); 
  gchar *state = gtk_entry_get_text(GTK_ENTRY(svt_gc.entry_reg[index]));

  sscanf(state, "%x", &val);

  error = svtvme_setState(board, svtvme_stringToObject(str), val);     
  if (error) {
    g_snprintf(result_str, NEL(result_str), "Error = %d\n", error);
    gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, result_str, -1);
  } 
}

/* 
 * Test board registers 
 * index  - Index in the array of five registers
 */
void svtgui_testBoardRegister(gint index)  {
  gchar result_str[20];

  gchar *str = gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(svt_gc.combo_reg[index])->entry)); 
  gint error = svtvme_testRegister(board, svtvme_stringToObject(str));     

  g_snprintf(result_str, NEL(result_str), "%d", error);
  gtk_entry_set_text(GTK_ENTRY(svt_gc.entry_reg[index]), result_str);
}

/* Inform about a missing feature which is advertised */
void svtgui_noImplementation (void) {
  gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, 
         "Work in progress ...\n", -1);
}

/* 
 * Open a clone of the application window 
 * item   - Pointer to the 'New Window' MenuItem widget
 * data   - Pointer to generic user data which one may pass to this routine when
 *          the menu item is selected
 */
void svtgui_newCB(GtkMenuItem *item, gpointer data) {
  GtkWidget *app = svtgui_appNew(NULL, NULL, 0, 0, NULL);
  gtk_widget_show_all(app);
}

/* 
 * Save data callback 
 * item   - Pointer to the 'Save' MenuItem widget
 * data   - Pointer to generic user data which one may pass to this routine when
 *          the menu item is selected
 */
void svtgui_saveCB(GtkMenuItem *item, gpointer data)  {
  gui_saveMessage(fc.defaultFilename, svt_gc.output_area);
}

/* 
 * Save contents of the python scripting area to a file
 * filename - The output python script filename
 */
void svtgui_saveScript(gpointer data) {
  char *fname = gtk_entry_get_text(GTK_ENTRY(gnome_file_entry_gtk_entry((GnomeFileEntry *) data)));
  g_return_if_fail(fname != NULL);

  gui_saveMessage(fname, svt_gc.script_area);
}
void svtgui_saveAsCB(GtkMenuItem *item, gpointer data) {
  GtkWidget *dialog;
  g_snprintf(fc.defaultFilename, NEL(fc.defaultFilename), "%s%s", getenv("PWD"), "/tmp.out");
  dialog = gnome_request_dialog(FALSE, 
                               "Output File Name",  
                               fc.defaultFilename,
                               0,
                               (GnomeStringCallback)svtgui_outputNameCB,
                                NULL, NULL);
  gtk_window_set_modal(GTK_WINDOW(dialog), TRUE);
}

/* 
 * Save text in the output area in a file
 * fname  - Name of the output file
 * data   - Pointer to generic user data which one may pass to this routine when
 *          the menu item is selected
 */
void svtgui_outputNameCB(const gchar *fname, gpointer data) {
  g_return_if_fail(fname != NULL);
  strcpy(fc.currentFilename, fname);
  gui_saveMessage(fc.currentFilename, svt_gc.output_area);
}

/* 
 * Close this window 
 * item  - Pointer to the 'Close Window' MenuItem widget
 * data  - Pointer to generic user data which one may pass to this routine when
 *         the menu item is selected
 */
void svtgui_closeCB(GtkMenuItem *item, gpointer data) {
  GtkWidget *app;

  svtgui_closeBoard(board);
  app = (GtkWidget *) data;
  svtgui_appClose(app);
}

/* 
 * Exit the Application 
 * item  - Pointer to the 'Exit' MenuItem widget
 * data  - Pointer to generic user data which one may pass to this routine when
 *         the menu item is selected
 */
void svtgui_exitCB(GtkMenuItem *item, gpointer data) {
  svtgui_shutPython();
  svtgui_closeBoard(board);
  gtk_main_quit();
}

/* 
 * Toggle verbose mode 
 * item  - Pointer to the 'Verbose Mode' MenuItem widget
 * data  - Pointer to generic user data which one may pass to this routine when
 *         the menu item is selected
 */
void svtgui_verboseModeCB(GtkMenuItem *item, gpointer data) {
  svt_gc.verbose_mode = !svt_gc.verbose_mode;
}

/* 
 * Toggle 1 word/line (default) to 10 words/line mode 
 * item  - Pointer to the 'Verbose Mode' MenuItem widget
 * data  - Pointer to generic user data which one may pass to this routine when
 *         the menu item is selected
 */
void svtgui_wordsModeCB(GtkMenuItem *item, gpointer data) {
  svt_gc.owpl_mode = !svt_gc.owpl_mode;
}

/* 
 * Clear output area 
 * item  - Pointer to the 'Clear Output Area' MenuItem widget
 * data  - Pointer to generic user data which one may pass to this routine when
 *         the menu item is selected
 */
void svtgui_clearMessageCB(GtkMenuItem *item, gpointer data) {
  gtk_editable_delete_text(GTK_EDITABLE(svt_gc.output_area), 0, -1);
}

/* 
 * Data formatting callback 
 * item  - Pointer to the 'Data Format' MenuItem widget
 * data  - Pointer to generic user data which one may pass to this routine when
 *         the menu item is selected
 */
void svtgui_boardFormatCB(GtkMenuItem *item, gpointer data) {
  gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, message, -1);
}

/* 
 * Data formatting callback 
 * item   - Pointer to the 'Data Format' MenuItem widget
 * data   - Pointer to generic user data which one may pass to this routine when
 *          the menu item is selected
 */
void svtgui_hexFormatCB(GtkMenuItem *item, gpointer data) {
  gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, message, -1);
}

/* 
 * Data formatting callback 
 * item   - Pointer to the 'Data Format' MenuItem widget
 * data   - Pointer to generic user data which one may pass to this routine when
 *          the menu item is selected
 */
void svtgui_decimalFormatCB(GtkMenuItem *item, gpointer data) {
  gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, message, -1);
}

/* 
 * Display brief info about the application 
 * item   - Pointer to the 'About' the application MenuItem widget
 * data   - Pointer to generic user data which one may pass to this routine when
 *          the menu item is selected
 */
void svtgui_aboutCB(GtkMenuItem *item, gpointer data) {
  static const char *authors[] = {               
    "Alessandro Barchiesi <Alex.Barchiesi@roma1.infn.it>",
    "Subir Sarkar <Subir.Sarkar@cern.ch>",
     NULL    
  };              
  static GtkWidget *dialog = NULL;
  GtkWidget *app = (GtkWidget *) data;

  if (dialog != NULL)  {
    g_assert(GTK_WIDGET_REALIZED(dialog));
    gdk_window_show(dialog->window);
    gdk_window_raise(dialog->window);
  }
  else {
    dialog = gnome_about_new(_("Single SVT Board Test Program"),
                         VERSION,
                         NULL,
                         authors,
                         _("An intuitive standalone SVT board teststand to perform dignostic "
                           "tests for each single SVT board from a unified Graphical User Interface."),
                         NULL);
    gtk_signal_connect(GTK_OBJECT(dialog),
                        "destroy",
                        GTK_SIGNAL_FUNC(gtk_widget_destroyed),
                        &dialog);

    gnome_dialog_set_parent(GNOME_DIALOG(dialog), GTK_WINDOW(app));
    gtk_widget_show(dialog);
  }
}

/* 
 * Handle all the Radio Button generated callbacks
 * togglebutton   - Pointer to the 'Help Topic' MenuItem widget
 * data           - Pointer to generic user data which one may pass to this routine when
 *                  the menu item is selected
 */
void svtgui_radioButtonToggleCB(GtkToggleButton *togglebutton, gpointer data) {
  gchar *name = gtk_widget_get_name(GTK_WIDGET(togglebutton));

  if (strcmp(name, "radio_mem_display") == 0) {
    gtk_widget_set_sensitive(svt_gc.entry_file, FALSE);
  }
  else if (strcmp(name, "radio_mem_dump") == 0) {
    gtk_widget_set_sensitive(svt_gc.entry_file, TRUE);
  }
  else if (strcmp(name, "radio_dump_fifo") == 0) {
    gtk_widget_set_sensitive(svt_gc.entry_fifo_file, TRUE);
  }
  else if (strcmp(name, "radio_display_fifo") == 0) {
    gtk_widget_set_sensitive(svt_gc.entry_fifo_file, FALSE);
  }
  else if (strcmp(name, "radio_fifo_num_word") == 0) {
    gtk_widget_set_sensitive(svt_gc.entry_fifo_nw, TRUE);
  }
  else if (strcmp(name, "radio_read_all_fifo") == 0) {
    gtk_widget_set_sensitive(svt_gc.entry_fifo_nw, FALSE);
  }
  else if (strcmp(name, "radio_mem_num_word") == 0) {
    gtk_widget_set_sensitive(svt_gc.entry_mem_nw, TRUE);
  }
  else if (strcmp(name, "radio_mem_all") == 0) {
    gtk_widget_set_sensitive(svt_gc.entry_mem_nw, FALSE);
  }
  else if (strcmp(name, "radio_spy_display") == 0) {
    gtk_widget_set_sensitive(svt_gc.text_spy_file, FALSE);
  }
  else if (strcmp(name, "radio_spy_dump") == 0) {
    gtk_widget_set_sensitive(svt_gc.text_spy_file, TRUE);
  }
  else if (strcmp(name, "radio_data_source[0]") == 0) {
    gtk_widget_set_sensitive(svt_gc.send_entry_file, FALSE);
    gtk_widget_set_sensitive(data, FALSE);
  }
  else if (strcmp(name, "radio_data_source[1]") == 0) {
    gtk_widget_set_sensitive(svt_gc.send_entry_file, TRUE);
    gtk_widget_set_sensitive(data, TRUE);
  }
  else if (strcmp(name, "radio_send_option[0]") == 0) {
    gtk_widget_set_sensitive(data, TRUE);
  }
  else if (strcmp(name, "radio_send_option[1]") == 0 ||
           strcmp(name, "radio_send_option[2]") == 0 ||
           strcmp(name, "radio_send_option[3]") == 0 ||
           strcmp(name, "radio_send_option[4]") == 0 ) {
    gtk_widget_set_sensitive(data, FALSE);
  }
  else if (strcmp(name, "radio_read_add") == 0) {
    gtk_entry_set_editable(GTK_ENTRY(data), FALSE);
  }
  else if (strcmp(name, "radio_write_add") == 0) {
    gtk_entry_set_editable(GTK_ENTRY(data), TRUE);
  }
}

/* Select a board in a crate callback */
void svtgui_selectBoardCB(GtkWidget *combo_crate_entry, GtkSelectionData *data,
  	                  guint info, guint time, gpointer combo)
{
  svtgui_selectBoard(combo_crate_entry);
}

/* 
 * Select a board in a crate 
 * combo_crate_entry   - Pointer to the entry box within the crate name combo
 */
void svtgui_selectBoard(GtkWidget *combo_crate_entry) {
  gint i, n_elem;
  GList *list = NULL;
  gint  slots[MAX_SLOTS];
  gint  sernums[MAX_SLOTS];
  gchar *boards[10];

  gchar *crate_name = gtk_entry_get_text(GTK_ENTRY(combo_crate_entry));

  /* Remove all the elements from the combo box */
  gtk_list_clear_items(GTK_LIST(GTK_COMBO(svt_gc.combo_board)->list), 0, -1);

  n_elem = svtgui_mapCrate(crate_name, slots, boards, sernums);
  for (i = 0; i < n_elem; i++) {
    list = g_list_append (list, boards[i]);
  }
  gtk_combo_set_popdown_strings (GTK_COMBO (svt_gc.combo_board), list);
  g_list_free (list);
}

/* Select a slot in a board callback */
void svtgui_selectSlotCB(GtkWidget *combo_board_entry, GtkSelectionData *data,
	                 guint info, guint time, gpointer combo)
{
  svtgui_selectSlot(combo_board_entry);
  svtgui_setAllAddresses();
}

/* 
 * Given a board, select the valid slots
 * combo_board_entry  The entry box related to board name combo
 */
void svtgui_selectSlot(GtkWidget *combo_board_entry) {
  gint i, n_elem;
  GList *list = NULL;
  gint slots[MAX_SLOTS];

  gchar *crate_name = gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(svt_gc.combo_crate)->entry));
  gchar *board_name = gtk_entry_get_text(GTK_ENTRY(combo_board_entry));
  /*
   * Remove all the elements from the slot combo box 
   */
  gtk_list_clear_items(GTK_LIST(GTK_COMBO(svt_gc.combo_slot)->list),0,-1);

  n_elem = svtgui_mapBoard(crate_name, board_name, slots);

  for (i = 0; i < n_elem; i++) {
    gchar slot_st[10];
    g_snprintf(slot_st, NEL(slot_st), "%d", slots[i]);
    list = g_list_append(list, slot_st);
  }
  gtk_combo_set_popdown_strings (GTK_COMBO (svt_gc.combo_slot), list); 
  g_list_free (list);
}

/* Dummy */
void svtgui_validateCrateCB(GtkWidget *combo_entry, GtkSelectionData *data, 
		            guint info, guint time, gpointer combo) 
{
}

/* 
 * Validate a board specifications 
 */
void svtgui_validateBoardCB(GtkWidget *combo_entry, GtkSelectionData *data, 
                            guint info, guint time, gpointer combo)
{
  svtgui_setAllAddresses();
}

/* Set the defaults */
void svtgui_setAllDefaults() {

  GtkWidget *combo_crate_entry = GTK_COMBO(svt_gc.combo_crate)->entry;
  GtkWidget *combo_board_entry = GTK_COMBO(svt_gc.combo_board)->entry;

  svtgui_selectBoard(combo_crate_entry);
  svtgui_selectSlot(combo_board_entry);
  svtgui_setAllAddresses();
}

/* Set Reg/Fifo/mem/spy properly for the board under consideration */
void svtgui_setAllAddresses() {
  gint i, board_type; 

  if (!board) return;
  board_type = svtvme_boardType(board);

  g_return_if_fail (svtgui_ensureBoardType(board_type));

  for (i = 0; i < NUM_REGS; i++)  
    svtgui_clearBoardRegister(svt_gc.entry_reg[i]); 

  if (board_type != current_board_type) {
    svtgui_setRegisters();
    svtgui_setMemories();
    svtgui_setSpies();
    svtgui_setFifos();
    current_board_type = board_type;
  }
}

/* 
 * Make sure that a board type is valid
 * board_type Board type integer
 */
gboolean svtgui_ensureBoardType(gint board_type) {
  gboolean retval = 0;
  if (board_type == AMB  ||
      board_type == AMS  ||
      board_type == HB   ||  
      board_type == MRG  ||  
      board_type == HF   ||  
      board_type == SC   ||  
      board_type == TF   ||  
      board_type == XTFA ||
      board_type == XTFC ||
      board_type == SVTB ||
      board_type == TRC  ||
      board_type == GB)
  {
    retval = 1;
  }
  return retval; 
}

/* 
 * Set board register names properly in the register name combo boxes
 * for the board under consideration
 */
void svtgui_setRegisters() {
  gint i, r, n_elem = 0, status;
  gint regIds[MAX_REG_ELEM];
  gchar **reg_name;
  GList *combo_items = NULL;
  GtkWidget *combo_reg_local[] = 
       {
          svt_gc.combo_reg[0], 
          svt_gc.combo_reg[1],
          svt_gc.combo_reg[2],
          svt_gc.combo_reg[3],
          svt_gc.combo_reg[4]
       };

  if (!board) return;
  for (r = 0; r < NUM_REGS; r++) {
    gtk_list_clear_items(GTK_LIST(GTK_COMBO(combo_reg_local[r])->list), 0, -1);  /* Clear all */
  }

  status = svtvme_getRegList(svtvme_boardType(board), MAX_REG_ELEM, &n_elem, regIds);
  if (status || !n_elem) {
    combo_items = g_list_append(combo_items, "No Registers");
    gtk_widget_set_sensitive(svt_gc.table_regs, FALSE);
    for (r = 0; r < NUM_REGS; r++) {
      gtk_combo_set_popdown_strings (GTK_COMBO (combo_reg_local[r]), combo_items);
    }

    g_list_free(combo_items);
    return;
  }

  /* Add the name of the Registers to the list */
  reg_name = g_new0(gchar*, n_elem);

  for (i = 0; i < n_elem; i++) {
    reg_name[i] = g_new0(gchar, 32);
    svtvme_objectName(regIds[i], reg_name[i]);
    combo_items = g_list_append (combo_items, reg_name[i]);
  }
  /* Now display the first n registers in the register entry boxes */
  for (r = 0; r < MIN(NUM_REGS, n_elem); r++) {
    gtk_combo_set_popdown_strings (GTK_COMBO (combo_reg_local[r]), combo_items);
    gtk_entry_set_text (GTK_ENTRY (GTK_COMBO(combo_reg_local[r])->entry), reg_name[r]);
  }
  /* Once the GUI element holds the components, delete the local list */
  g_list_free(combo_items);
  for (i = 0; i < n_elem; i++) {
    g_free(reg_name[i]);
  }  
  g_free(reg_name);
}

/* 
 * Set board memory names properly in the memory name combo box
 * for the board under consideration
 */
void svtgui_setMemories() {
  gint i, n_elem = 0, status;
  gint memIds[MAX_MEM_ELEM];
  gchar **mem_name;
  GList *combo_items = NULL;

  if (!board) return;

  gtk_list_clear_items(GTK_LIST(GTK_COMBO(svt_gc.combo_mem)->list), 0, -1); 

  status = svtvme_getMemList(svtvme_boardType(board), MAX_MEM_ELEM, &n_elem, memIds);
  status = svtvme_getSpyList(svtvme_boardType(board), MAX_MEM_ELEM-n_elem, &i, memIds+n_elem);
  n_elem+=i;
  assert (n_elem<MAX_MEM_ELEM);
  if (status || !n_elem) {
    combo_items = g_list_append(combo_items, "No Memory Reg");
    gtk_widget_set_sensitive(svt_gc.table_mem, FALSE);
    gtk_combo_set_popdown_strings (GTK_COMBO (svt_gc.combo_mem), combo_items);

    g_list_free(combo_items);
    return;
  }

  gtk_widget_set_sensitive(svt_gc.table_mem, TRUE);

  mem_name = g_new0(gchar*, n_elem);
  for (i = 0; i < n_elem; i++){
    mem_name[i] = g_new0(gchar, 32);
    svtvme_objectName(memIds[i], mem_name[i]); 
    combo_items = g_list_append (combo_items, mem_name[i]);
  }
  gtk_combo_set_popdown_strings (GTK_COMBO (svt_gc.combo_mem), combo_items);
  g_list_free (combo_items);
  for (i = 0; i < n_elem; i++) {
    g_free(mem_name[i]);
  }  
  g_free(mem_name);
}

/* 
 * Set board spy buffer names properly in the spy name combo box
 * for the board under consideration
 */
void svtgui_setSpies() {
  gint n_elem = 0, i, status, spyIds[MAX_SPY_ELEM], board_type;
  gchar **spy_name;
  gchar label[100], board_name[16];
  GList *combo_items = NULL;

  if (!board) return;
  board_type = svtvme_boardType(board);

  gtk_list_clear_items(GTK_LIST(GTK_COMBO(svt_gc.combo_spy)->list), 0, -1); 
  status = svtvme_getSpyList(board_type, MAX_SPY_ELEM, &n_elem, spyIds);

  /* AMB and SC do not have spy buffers */
  if (status || !n_elem) {
    combo_items = g_list_append(combo_items, "No Spy Buffer");
    g_snprintf(label, NEL(label), "%s %s", "No", "Spy Buffer");
    gtk_widget_set_sensitive(svt_gc.table_spy, FALSE);
    gtk_combo_set_popdown_strings (GTK_COMBO (svt_gc.combo_spy), combo_items);

    g_list_free(combo_items);
    return;
  }

  gtk_widget_set_sensitive(svt_gc.table_spy, TRUE);

  spy_name = g_new0(gchar*, n_elem);
  for (i = 0; i < n_elem; i++) {
    spy_name[i] = g_new0(gchar, 32);
    svtvme_objectName(spyIds[i], spy_name[i]);
    combo_items = g_list_append (combo_items, spy_name[i]);
  }

  svtvme_boardName(svtvme_boardType(board), board_name);
  g_snprintf(label, NEL(label), "%s %s", board_name, "Spy Buffer");

  gtk_label_set_text(GTK_LABEL(svt_gc.label_spy_buffer), label);
  gtk_combo_set_popdown_strings (GTK_COMBO (svt_gc.combo_spy), combo_items);

  g_list_free(combo_items);

  /* Free resources */
  for (i = 0; i < n_elem; i++) {
    g_free(spy_name[i]);
  }  
  g_free(spy_name);
}

/* 
 * Set board Fifo names properly in the fifo combo box for the board 
 * under consideration 
 */
void svtgui_setFifos() {
  gint n_elem = 0, i, status, fifoIds[MAX_FIFO_ELEM], board_type;
  gchar **fifo_name;
  GList *combo_items = NULL;

  if (!board) return;

  board_type = svtvme_boardType(board);
  gtk_list_clear_items(GTK_LIST(GTK_COMBO(svt_gc.combo_fifo)->list), 0, -1); 

  status = svtvme_getFifoList(board_type, MAX_FIFO_ELEM, &n_elem, fifoIds);

  /* AMB and SC do not have fifos */
  if (status || !n_elem) {
    combo_items = g_list_append(combo_items, "No FIFO");
    gtk_widget_set_sensitive(svt_gc.table_fifo_1, FALSE);
    gtk_combo_set_popdown_strings (GTK_COMBO (svt_gc.combo_fifo), combo_items);

    g_list_free (combo_items);
    return;
  }

  gtk_widget_set_sensitive(svt_gc.table_fifo_1, TRUE);

  fifo_name = g_new0(gchar*, n_elem);
  for (i = 0; i < n_elem; i++) {

#if 0
    /* Do not try to read TF_BP_FIFO for now */
    if (fifoIds[i] == TF_BP_FIFO) continue;
#endif
    fifo_name[i] = g_new0(gchar, 32); 
    svtvme_objectName(fifoIds[i], fifo_name[i]);
    combo_items = g_list_append (combo_items, fifo_name[i]);
      
    gnome_pixmap_load_file((GnomePixmap *) svt_gc.pixmap_fifo[i], svt_gc.pix_file_gray);
    gtk_widget_show(svt_gc.pixmap_fifo[i]);
  }

  for (i = n_elem; i < MAX_FIFO; i++) {
    gtk_widget_hide(svt_gc.pixmap_fifo[i]);
    gtk_widget_hide(svt_gc.name_fifo[i]);
  }
  gtk_combo_set_popdown_strings (GTK_COMBO (svt_gc.combo_fifo), combo_items);

  g_list_free (combo_items);
  for (i = 0; i < n_elem; i++) {
    g_free(fifo_name[i]);
  }  
  g_free(fifo_name);
}

/* 
 * Close the board handle 
 * board The board handle
 */
void svtgui_closeBoard(svtvme_h board)  {
  gint error, slot;
  gchar err_str[MAX_STRING_LEN];
  gchar crate_name[32], board_name[16];

  if (!board) return;

  error = svtvme_boardCrate(board, crate_name);
  error = svtvme_boardName(svtvme_boardType(board), board_name);
  slot  = svtvme_boardSlot(board);

  error = svtvme_closeBoard(board);
  err_str[0] = '\0';
  if (error) {
    g_snprintf(err_str, NEL(err_str), "Error closing board at address %p\n", board);
    g_warning("svtgui_closeBoard() -> %s", err_str);
    gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, err_str, -1);
  }
  else {
    g_snprintf(err_str, NEL(err_str), "Board %s/%d/%s closed at address %p\n", 
                              crate_name, slot, board_name, board);
    board = 0;
    if (svt_gc.verbose_mode) 
      gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, err_str, -1);
  }
}

/* Read status of spy buffers */
void svtgui_readSpyStatus(void) {
  gchar str[10], *spy_buf;
  gint pointer, spy_id = 0;
  gint status, n_elem = 0, spyIds[MAX_SPY_ELEM];
  if (!board) return;

  status = svtvme_getSpyList(svtvme_boardType(board), MAX_SPY_ELEM, &n_elem, spyIds);
  if (n_elem <= 0) return;

  /* Get which spy buffer is selected */
  spy_buf = gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(svt_gc.combo_spy)->entry));
  spy_id = svtvme_stringToObject(spy_buf);

  g_return_if_fail(spy_id > 0);

  /* Pointer */
  pointer = svtvme_spyCounter(board, spy_id);
  g_snprintf(str, NEL(str), "%6.6x", pointer);
  gtk_entry_set_text(GTK_ENTRY(svt_gc.entry_pointer), str);

  /* Wrap */
  if (svtvme_isWrapped(board, spy_id)) {
    gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_spy_wrap, svt_gc.pix_file_red); 
  }
  else {
    gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_spy_wrap, svt_gc.pix_file_green); 
  }
 
  /* Freeze */
  if (svtvme_isFrozen(board, spy_id)) {
    gnome_pixmap_load_file((GnomePixmap *) svt_gc.pixmap_spy_freeze, svt_gc.pix_file_red); 
  }
  else {
    gnome_pixmap_load_file((GnomePixmap *) svt_gc.pixmap_spy_freeze, svt_gc.pix_file_green); 
  }      	
}

/* 
 * Reset clock 
 * clock The clock widget
 */
void svtgui_resetClock(GtkWidget *clock) {
  gtk_clock_stop(GTK_CLOCK(clock));
  gtk_clock_set_seconds(GTK_CLOCK(clock), 0); 
  gtk_clock_start(GTK_CLOCK(clock)); 
}

/* 
 * Make sure the board is open before any board specific action
 * is performed, other a seg fault is inevitable.
 *
 * crate_name Name of the SVT crate
 * board_name Name of he board under consideration
 * slot_num   slot number where the board under consideration sits
 */
void svtgui_ensureOpenBoard(const gchar *crate_name, const gchar *board_name, gint slot_num) {
  gint error;
  static gchar crate_save[20];
  static gchar board_save[12];

  if (board) {
    error = svtvme_boardCrate(board, crate_save);  
    error = svtvme_boardName(svtvme_boardType(board), board_save);  
  }
  if (!board || (  
           (strcmp(crate_name, crate_save) != 0) || 
           (strcmp(board_name, board_save) != 0) ||
	   (slot_num != svtvme_boardSlot(board)) ))
    {
      if (board) svtgui_closeBoard(board);
      svtgui_openBoard(crate_name, board_name, slot_num);
      svtgui_setAllAddresses();
    }
}

/* 
 * Open connection to a board. After one obtains a valid
 * board handle, if Python has already been initialized,
 * passes the board handle to th einterpreter.
 * 
 * crate_name Name of the SVT crate
 * board_name Name of he board under consideration
 * slot_num   slot number where the board under consideration sits
 */
void svtgui_openBoard(const gchar *crate_name, const gchar *board_name, gint slot_num) {
  gint type, serial, status;
  gchar str[20], name[20];
  gchar err_str[100];

  board = svtvme_openBoard(crate_name, slot_num, SVTB);
  if (!board) {
    g_snprintf(err_str, NEL(err_str), "Could not open generic board at %s/%s/%d\n", 
      crate_name, "SVTB", slot_num);
      gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, err_str, -1);
    return;
  }
  status = svtvme_getBoardIdentifier(board, &type, &serial);

  g_return_if_fail(status == 0);

  svtvme_closeBoard(board);  /* Close generic board and open the specific one */
  board = 0;

  board = svtvme_openBoard(crate_name, slot_num, type);
  if (!board) {
    g_snprintf(err_str, NEL(err_str), "Could not open board %s (type %d) at %s/%d\n", 
      board_name, type, crate_name, slot_num);
    gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, err_str, -1);
    return;
  }
  svtgui_initPython();

  svtvme_boardName(svtvme_boardType(board), name);
  g_snprintf(err_str, NEL(err_str), "%s/%s/%d board opened correctly at address %p\n", 
	 crate_name, board_name, slot_num, board);
  if (svt_gc.verbose_mode) 
    gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, err_str, -1);

  if (svtvme_testIDPROM(board)) {
    g_snprintf(str, NEL(str), "%d %s", type, name);
    gtk_entry_set_text(GTK_ENTRY(svt_gc.entry_type), str);
    g_snprintf(str, NEL(str), "%d", serial);
    gtk_entry_set_text(GTK_ENTRY(svt_gc.entry_serial), str);
    gtk_label_set_text(GTK_LABEL(svt_gc.label_idprom_check), "Check OK");

    gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_idprom, svt_gc.pix_file_green); 
  }
  else {
    gtk_label_set_text(GTK_LABEL(svt_gc.label_idprom_check), "Check Fails");
    gnome_pixmap_load_file((GnomePixmap *)svt_gc.pixmap_idprom, svt_gc.pix_file_red); 
  }
}

/* 
 * Read the main Board error registers 
 * board_name  - Name of the board under consideration
 */
void svtgui_readErrorReg(gint board_type) {
  gint i, reg = -1;
  gint error;
  uint4 state = 0;
  gchar result_str[60];

  static struct 
  {
    gint board_type;
    gint error_reg;
  } board_to_reg [] =  { 
            {AMS,  AMS_ERROR}, 
            {HB,   HB_ERROR},
            {MRG,  MRG_ERROR}, 
            {HF,   HF_ALOCALREG},
            {TF,   TF_ERRSTAT_2}, 
            {XTFA, XTFA_ERROR_REG},
            {0,    0}
          };
  for (i = 0; board_to_reg[i].board_type != 0; i++) {
    if (board_type == board_to_reg[i].board_type) {
      reg = board_to_reg[i].error_reg;      
    }
  }

  if (reg < 0) {
#ifdef __DEBUG__
    g_warning("%s %s", "No Error register is Listed for this Board Type", board_type);
#endif
    return;
  }
  error = svtvme_getState(board, reg, &state);     
  if (!error) {
    g_snprintf(result_str, NEL(result_str), "%d", state);
    gtk_entry_set_text(GTK_ENTRY(svt_gc.entry_errreg), result_str);
  }
  else {
    g_snprintf(result_str, NEL(result_str), 
      "Error = %d\n reading %d Error register\n", error, board_type);
    gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, result_str, -1);
  } 
}

/* 
 * Selecting a crate should trigger looking for the boards and the non-empty 
 * slots numbers present in that crate. This function connects to all the board
 * one after the other in the crate using generic type and thereafter collects
 * relevant informations.
 * 
 * crate      - SVT Crate
 * slot_list  - Array of slots in the crate
 * board_list - Array of board names in the crate
 */
gint svtgui_mapCrate(const gchar *crate, gint *slot_list,
		     gchar **board_list, gint *sernum_list) {
  gint status = 0, ivalid = 0;
  svtvme_h board = 0;
  gint slot, ser_num, i, boardId;
  char name[5];

  for (i = 0; i < MAX_SLOTS-1; i++) {
    slot = i + 2;
    svtvme_probeSlot(crate,slot,&boardId,&ser_num);
    svtvme_boardName(boardId, name);
    /*
    board = svtvme_openBoard(crate, slot, SVTB);
    g_return_val_if_fail(board, -1);

    status = svtvme_getBoardIdentifier(board, &boardId, &ser_num);
    if (status == 0) 
      svtvme_boardName(boardId, name);
    else {
      boardId = ser_num = 0;
      g_snprintf(name, NEL(name), "%s", "Empty");
    }
    */
    /* Watch out for Jane's board -- do it better later */
    /*
    if (!strcmp(name, "???")) boardId = ser_num = 0;
    */
 
    if (boardId && ser_num) {
       slot_list[ivalid]  = slot;
       sernum_list[ivalid] = ser_num;
       strcpy(board_list[ivalid], name);
       ++ivalid;
    }
    svtvme_closeBoard(board);
  }
  return ivalid;
}

/* 
 * For the standard configuration, selecting a board should trigger
 * looking for the slots numbers for that board
 * crate      - Crate Name 
 * board      - Board name
 * slot_list  - The slot array correspoding to a board
 */
gint svtgui_mapBoard(const gchar *crate, const gchar *board, gint *slot_list) {
  return 0;
}

/* 
 * Get the IDProm of a board 
 * board    - Board handle
 * serial   - Serial number
 * version  - version
 */
gint svtgui_getIdprom(svtvme_h board, gchar *serial, gchar *version) {
  uint4 *idprom;
  gint num_word, i;
  gchar a;
  static int SER_LN = 8;
  num_word = 64*1024;
  g_return_val_if_fail(idprom = g_new0(uint4, num_word), -1);

  svtvme_readMemory(board, SVTB_64K_IDPROM, num_word, idprom);

  for (i = 0; i < 32; i++) {
    a = (gchar) (idprom[i]>>24 & 0xff);
    if(i < 8){
      serial[i] = a;
    }
    else{
      version[i - SER_LN] = a;
    }
  }
  g_free (idprom);
  return 0;
}

/* 
 * A 'no implementation' dialog box 
 * widget - Button/Menuitem widget which causes the callback
 * data   - Pointer to the parent widget to the dialog box 
 *          passed as a generic pointer
 */
void svtgui_noImpCB(GtkWidget* widget, gpointer data) {
  GtkWidget* dialog;
  GtkWidget* app;
  
  app = (GtkWidget *) data;

  dialog = gnome_ok_dialog_parented(_("Edit data area, ... Work in progress ..."),
          GTK_WINDOW(app));
}
void svtgui_mapCrateCB(GtkButton *button, gpointer data) {
  static gint MAX_BOARDS = 20;
  gint i, n_elem;
  gint  slots[MAX_SLOTS];
  gchar **boards;
  gint sernums[MAX_SLOTS];
  gchar header[256], value[128];

  gchar *crate_name = gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(svt_gc.combo_crate)->entry)); 
  boards = g_new0(gchar*, MAX_BOARDS);
  for (i = 0; i < MAX_BOARDS; i++)
    boards[i] = g_new(gchar, 32);
    
  n_elem = svtgui_mapCrate(crate_name, slots, boards, sernums);

  g_snprintf(header, NEL(header), "\nMap for crate %s:\n  Slot     Board\n===============================\n", crate_name);
  if (svt_gc.verbose_mode) g_print(header);
  gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, header, -1);

  for (i = 0; i < n_elem; i++) {
    g_snprintf(value, NEL(value), " %2d  %4s serial %3d\n", slots[i], boards[i], sernums[i]);
    if (svt_gc.verbose_mode) g_print(value);
    gtk_text_insert(GTK_TEXT(svt_gc.output_area), NULL, NULL, NULL, value, -1);
  }
  for (i = 0; i < MAX_BOARDS; i++)
    g_free(boards[i]);
  g_free(boards);
}
